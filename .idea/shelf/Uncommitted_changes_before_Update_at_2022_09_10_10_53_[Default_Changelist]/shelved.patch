Index: PAMI/correlatedPattern/basic/CPGrowth.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#  Copyright (C)  2021 Rage Uday Kiran\n#\n#      This program is free software: you can redistribute it and/or modify\n#      it under the terms of the GNU General Public License as published by\n#      the Free Software Foundation, either version 3 of the License, or\n#      (at your option) any later version.\n#\n#      This program is distributed in the hope that it will be useful,\n#      but WITHOUT ANY WARRANTY; without even the implied warranty of\n#      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#      GNU General Public License for more details.\n#\n#      You should have received a copy of the GNU General Public License\n#      along with this program.  If not, see <https://www.gnu.org/licenses/>.\n#      Copyright (C)  2021 Rage Uday Kiran\n\n#      This program is free software: you can redistribute it and/or modify\n#      it under the terms of the GNU General Public License as published by\n#      the Free Software Foundation, either version 3 of the License, or\n#      (at your option) any later version.\n#\n#      This program is distributed in the hope that it will be useful,\n#      but WITHOUT ANY WARRANTY; without even the implied warranty of\n#      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#      GNU General Public License for more details.\n#\n#      You should have received a copy of the GNU General Public License\n#      along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n\nfrom PAMI.correlatedPattern.basic import abstract as _ab\n\n#frequentPatterns = {}\nclass _Node:\n    \"\"\"\n    A class used to represent the node of frequentPatternTree\n\n\n    Attributes :\n    ----------\n        itemId : int\n            storing item of a node\n        counter : int\n            To maintain the support of node\n        parent : node\n            To maintain the parent of every node\n        child : list\n            To maintain the children of node\n        nodeLink : node\n            Points to the node with same itemId\n\n    Methods :\n    -------\n\n        getChild(itemName)\n            returns the node with same itemName from frequentPatternTree\n    \"\"\"\n\n    def __init__(self):\n        self.itemId = -1\n        self.counter = 1\n        self.parent = None\n        self.child = []\n        self.nodeLink = None\n\n    def getChild(self, id1):\n        for i in self.child:\n            if i.itemId == id1:\n                return i\n        return None\n\n\nclass _Tree:\n    \"\"\"\n        A class used to represent the frequentPatternGrowth tree structure\n\n    Attributes :\n    ----------\n        headerList : list\n            storing the list of items in tree sorted in ascending of their supports\n        mapItemNodes : dictionary\n            storing the nodes with same item name\n        mapItemLastNodes : dictionary\n            representing the map that indicates the last node for each item\n        root : Node\n            representing the root Node in a tree\n\n\n    Methods :\n    -------\n        createHeaderList(items,minSup)\n            takes items only which are greater than minSup and sort the items in ascending order\n        addTransaction(transaction)\n            creating transaction as a branch in frequentPatternTree\n        fixNodeLinks(item,newNode)\n            To create the link for nodes with same item\n        printTree(Node)\n            gives the details of node in frequentPatternGrowth tree\n        addPrefixPath(prefix,port,minSup)\n           It takes the items in prefix pattern whose support is >=minSup and construct a subtree\n    \"\"\"\n\n    def __init__(self):\n        self.headerList = []\n        self.mapItemNodes = {}\n        self.mapItemLastNodes = {}\n        self.root = _Node()\n\n    def addTransaction(self, transaction):\n        \"\"\"\n        adding transaction into tree\n\n        :param transaction : it represents the one transactions in database\n        :type transaction : list\n        \"\"\"\n\n        current = self.root\n        for i in transaction:\n            child = current.getChild(i)\n            if child is None:\n                newNode = _Node()\n                newNode.itemId = i\n                newNode.parent = current\n                current.child.append(newNode)\n                self.fixNodeLinks(i, newNode)\n                current = newNode\n            else:\n                child.counter += 1\n                current = child\n\n    def fixNodeLinks(self, item, newNode):\n        \"\"\"\n        Fixing node link for the newNode that inserted into frequentPatternTree\n\n        :param item: it represents the item of newNode\n        :type item : int\n        :param newNode : it represents the newNode that inserted in frequentPatternTree\n        :type newNode : Node\n\n        \"\"\"\n        if item in self.mapItemLastNodes.keys():\n            lastNode = self.mapItemLastNodes[item]\n            lastNode.nodeLink = newNode\n        self.mapItemLastNodes[item] = newNode\n        if item not in self.mapItemNodes.keys():\n            self.mapItemNodes[item] = newNode\n\n    def printTree(self, root):\n        \"\"\"\n        This method is to find the details of parent,children,support of Node\n\n        :param root: it represents the Node in frequentPatternTree\n        :type root: Node\n\n        \n        \"\"\"\n\n        if root.child is None:\n            return\n        else:\n            for i in root.child:\n                print(i.itemId, i.counter, i.parent.itemId)\n                self.printTree(i)\n\n    def createHeaderList(self, mapSupport, minSup):\n        \"\"\"\n        To create the headerList\n\n        :param mapSupport : it represents the items with their supports\n        :type mapSupport : dictionary\n        :param minSup : it represents the minSup\n        :param minSup : float\n        \"\"\"\n        \n        t1 = []\n        for x, y in mapSupport.items():\n            if y >= minSup:\n                t1.append(x)\n        itemSetBuffer = [k for k, v in sorted(mapSupport.items(), key=lambda x: x[1], reverse=True)]\n        self.headerList = [i for i in t1 if i in itemSetBuffer]\n\n    def addPrefixPath(self, prefix, mapSupportBeta, minSup):\n        \"\"\"\n        To construct the conditional tree with prefix paths of a node in frequentPatternTree\n\n        :param prefix : it represents the prefix items of a Node\n        :type prefix : list\n        :param mapSupportBeta : it represents the items with their supports\n        :param mapSupportBeta : dictionary\n        :param minSup : to check the item meets with minSup\n        :param minSup : float\n        \"\"\"\n        pathCount = prefix[0].counter\n        current = self.root\n        prefix.reverse()\n        for i in range(0, len(prefix) - 1):\n            pathItem = prefix[i]\n            if mapSupportBeta.get(pathItem.itemId) >= minSup:\n                child = current.getChild(pathItem.itemId)\n                if child is None:\n                    newNode = _Node()\n                    newNode.itemId = pathItem.itemId\n                    newNode.parent = current\n                    newNode.counter = pathCount\n                    current.child.append(newNode)\n                    current = newNode\n                    self.fixNodeLinks(pathItem.itemId, newNode)\n                else:\n                    child.counter += pathCount\n                    current = child\n\n\nclass CPGrowth(_ab._correlatedPatterns):\n    \"\"\"\n        CPGrowth is one of the fundamental algorithm to discover correlated frequent patterns in a transactional database.\n        it is based on traditional Fpgrowth Algorithm,This algorithm uses breadth-first search technique to find the \n        correlated Frequent patterns in transactional database.\n    \n    Attributes :\n    ----------\n        iFile : file\n            Name of the Input file to mine complete set of frequent patterns\n        oFile : file\n            Name of the output file to store complete set of frequent patterns\n        memoryUSS : float\n            To store the total amount of USS memory consumed by the program\n        memoryRSS : float\n            To store the total amount of RSS memory consumed by the program\n        startTime:float\n            To record the start time of the mining process\n        endTime:float\n            To record the completion time of the mining process\n        minSup : int\n            The user given minSup\n        minAllConf: float\n            The user given minimum all confidence Ratio(should be in range of 0 to 1)\n        Database : list\n            To store the transactions of a database in list\n        mapSupport : Dictionary\n            To maintain the information of item and their frequency\n        lno : int\n            it represents the total no of transactions\n        tree : class\n            it represents the Tree class\n        itemSetCount : int\n            it represents the total no of patterns\n        finalPatterns : dict\n            it represents to store the patterns\n        itemSetBuffer : list\n            it represents the store the items in mining\n        maxPatternLength : int\n           it represents the constraint for pattern length\n\n    Methods :\n    -------\n        startMine()\n            Mining process will start from here\n        getPatterns()\n            Complete set of patterns will be retrieved with this function\n        savePatterns(oFile)\n            Complete set of frequent patterns will be loaded in to a output file\n        getPatternsAsDataFrame()\n            Complete set of frequent patterns will be loaded in to a dataframe\n        getMemoryUSS()\n            Total amount of USS memory consumed by the mining process will be retrieved from this function\n        getMemoryRSS()\n            Total amount of RSS memory consumed by the mining process will be retrieved from this function\n        getRuntime()\n            Total amount of runtime taken by the mining process will be retrieved from this function\n        creatingItemSets(fileName)\n            Scans the dataset or dataframes and stores in list format\n        saveAllCombination(tempBuffer,s,position,prefix,prefixLength)\n            Forms all the combinations between prefix and tempBuffer lists with support(s)\n        frequentPatternGrowthGenerate(frequentPatternTree,prefix,port)\n            Mining the frequent patterns by forming conditional frequentPatternTrees to particular prefix item.\n            mapSupport represents the 1-length items with their respective support\n        creatingItemSets(iFileName)\n            Method to Storing the complete transactions of the database file in a database variable\n        saveItemSet(prefix, prefixLength, support)\n            To save the frequent patterns mined form frequentPatternTree\n\n    Executing the code on terminal\n    ------------------------------\n        Format: python3 CPGrowth.py <inputFile> <outputFile> <minSup> <minAllConf> <sep>\n        Examples: python3 CPGrowth.py inp.txt output.txt 4.0 0.3   (minSup will be considered in percentage of database transactions)\n                  python3 CPGrowth.py  patterns.txt 4  0.3   (minSup will be considered in support count or frequency)\n                                                                (it will consider '\\t' as separator)\n                  python3 CPGrowth.py sampleDB.txt patterns.txt 0.23 0.2  , \n                                                                (it will consider ',' as separator)\n\n    Sample run of the importing code:\n    ---------------------------------\n\n        from PAMI.correlatedPattern.basic import CPGrowth as alg\n\n        obj = alg.CPGrowth(iFile, minSup,minAllConf)\n\n        obj.startMine()\n\n        correlatedPatterns = obj.getPatterns()\n\n        print(\"Total number of correlated frequent Patterns:\", len(correlatedPatterns))\n\n        obj.savePatterns(oFile)\n\n        Df = obj.getPatternInDf()\n\n        memUSS = obj.getMemoryUSS()\n\n        print(\"Total Memory in USS:\", memUSS)\n\n        memRSS = obj.getMemoryRSS()\n\n        print(\"Total Memory in RSS\", memRSS)\n\n        run = obj.getRuntime()\n\n        print(\"Total ExecutionTime in seconds:\", run)\n\n    Credits:\n    --------\n        The complete program was written by B.Sai Chitra  under the supervision of Professor Rage Uday Kiran.\n\n        \"\"\"\n\n    _startTime = float()\n    _endTime = float()\n    _minSup = float()\n    _finalPatterns = {}\n    _iFile = \" \"\n    _oFile = \" \"\n    _memoryUSS = float()\n    _memoryRSS = float()\n    _minAllConf = 0.0\n    _Database = []\n    _mapSupport = {}\n    _lno = 0\n    _tree = _Tree()\n    _itemSetBuffer = None\n    _fpNodeTempBuffer = []\n    _itemSetCount = 0\n    _maxPatternLength = 1000\n    _sep = \"\\t\"\n\n    def __init__(self, iFile, minSup, minAllConf, sep=\"\\t\"):\n        super().__init__(iFile, minSup, minAllConf, sep)\n\n    def _creatingItemSets(self):\n        \"\"\"\n            Storing the complete transactions of the database/input file in a database variable\n\n            \"\"\"\n        self._Database = []\n        if isinstance(self._iFile, _ab._pd.DataFrame):\n            if self._iFile.empty:\n                print(\"its empty..\")\n            i = self._iFile.columns.values.tolist()\n            if 'Transactions' in i:\n                self._Database = self._iFile['Transactions'].tolist()\n        if isinstance(self._iFile, str):\n            if _ab._validators.url(self._iFile):\n                data = _ab._urlopen(self._iFile)\n                for line in data:\n                    line.strip()\n                    line = line.decode(\"utf-8\")\n                    temp = [i.rstrip() for i in line.split(self._sep)]\n                    temp = [x for x in temp if x]\n                    self._Database.append(temp)\n            else:\n                try:\n                    with open(self._iFile, 'r', encoding='utf-8') as f:\n                        for line in f:\n                            line.strip()\n                            temp = [i.rstrip() for i in line.split(self._sep)]\n                            temp = [x for x in temp if x]\n                            #print(temp)\n                            self._Database.append(temp)\n                except IOError:\n                    print(\"File Not Found\")\n                    quit()\n\n    def _getRatio(self, prefix, prefixLength, s):\n        \"\"\"\n            A Function to get itemSet Ratio\n            :param prefix:the path\n            :type prefix: list\n            :param prefixLength: length\n            :type prefixLength:int\n            :s :current ratio\n            :type s:float\n            :return: minAllConf of prefix\n            :rtype:float\n        \"\"\"\n        maximums = 0\n        for ele in range(prefixLength):\n            i = prefix[ele]\n            if maximums < self._mapSupport.get(i):\n                maximums = self._mapSupport.get(i)\n        return s / maximums\n\n    def _frequentOneItem(self):\n        \"\"\"Generating One frequent items sets\n\n        \"\"\"\n        self._mapSupport = {}\n        for i in self._Database:\n            for j in i:\n                if j not in self._mapSupport:\n                    self._mapSupport[j] = 1\n                else:\n                    self._mapSupport[j] += 1\n\n    def _saveItemSet(self, prefix, prefixLength, support):\n        \"\"\"To save the frequent patterns mined form frequentPatternTree\n\n        :param prefix: the frequent pattern\n        :type prefix: list\n        :param prefixLength : the length of a frequent pattern\n        :type prefixLength : int\n        :param support: the support of a pattern\n        :type support :  int\n        :The frequent patterns are update into global variable finalPatterns\n        \"\"\"\n        allconf = self._getRatio(prefix, prefixLength, support)\n        if allconf < self._minAllConf:\n            return\n        l = []\n        for i in range(prefixLength):\n            l.append(prefix[i])\n        self._itemSetCount += 1\n        self._finalPatterns[tuple(l)] = str(support)+\" : \"+str(allconf)\n    \n    def _convert(self, value):\n        \"\"\"\n        to convert the type of user specified minSup value\n        :param value: user specified minSup value\n        :return: converted type\n        \"\"\"\n        if type(value) is int:\n            value = int(value)\n        if type(value) is float:\n            value = (len(self._Database) * value)\n        if type(value) is str:\n            if '.' in value:\n                value = float(value)\n                value = (len(self._Database) * value)\n            else:\n                value = int(value)\n        return value\n\n    def _saveAllCombinations(self, tempBuffer, s, position, prefix, prefixLength):\n        \"\"\"Generating all the combinations for items in single branch in frequentPatternTree\n\n        :param tempBuffer: items in a list\n        :type tempBuffer: list\n        :param s : support at leaf node of a branch\n        :param position : the length of a tempBuffer\n        :type position : int\n        :param prefix : it represents the list of leaf node\n        :type prefix : list\n        :param prefixLength : the length of prefix\n        :type prefixLength :int\n        \n        \"\"\"\n        max1 = 1 << position\n        for i in range(1, max1):\n            newPrefixLength = prefixLength\n            for j in range(position):\n                isSet = i & (1 << j)\n                if isSet > 0:\n                    prefix.insert(newPrefixLength, tempBuffer[j].itemId)\n                    newPrefixLength += 1\n            self._saveItemSet(prefix, newPrefixLength, s)\n\n    def _frequentPatternGrowthGenerate(self, frequentPatternTree, prefix, prefixLength, mapSupport):\n        \"\"\"\n\n        Mining the fp tree\n\n        :param frequentPatternTree: it represents the frequentPatternTree\n        :type frequentPatternTree: class Tree\n        :param prefix : it represents a empty list and store the patterns that are mined\n        :type prefix : list\n        :param param prefixLength : the length of prefix\n        :type prefixLength :int\n        :param mapSupport : it represents the support of item\n        :type mapSupport : dictionary\n\n        \"\"\"\n\n        singlePath = True\n        position = 0\n        s = 0\n        if len(frequentPatternTree.root.child) > 1:\n            singlePath = False\n        else:\n            currentNode = frequentPatternTree.root.child[0]\n            while True:\n                if len(currentNode.child) > 1:\n                    singlePath = False\n                    break\n                self._fpNodeTempBuffer.insert(position, currentNode)\n                s = currentNode.counter\n                position += 1\n                if len(currentNode.child) == 0:\n                    break\n                currentNode = currentNode.child[0]\n        if singlePath is True:\n            self._saveAllCombinations(self._fpNodeTempBuffer, s, position, prefix, prefixLength)\n        else:\n            for i in reversed(frequentPatternTree.headerList):\n                item = i\n                support = mapSupport[i]\n                betaSupport = support\n                prefix.insert(prefixLength, item)\n                self._saveItemSet(prefix, prefixLength + 1, betaSupport)\n                if prefixLength + 1 < self._maxPatternLength:\n                    prefixPaths = []\n                    path = frequentPatternTree.mapItemNodes.get(item)\n                    mapSupportBeta = {}\n                    while path is not None:\n                        if path.parent.itemId != -1:\n                            prefixPath = []\n                            prefixPath.append(path)\n                            pathCount = path.counter\n                            parent1 = path.parent\n                            while parent1.itemId != -1:\n                                prefixPath.append(parent1)\n                                if mapSupportBeta.get(parent1.itemId) is None:\n                                    mapSupportBeta[parent1.itemId] = pathCount\n                                else:\n                                    mapSupportBeta[parent1.itemId] = mapSupportBeta[parent1.itemId] + pathCount\n                                parent1 = parent1.parent\n                            prefixPaths.append(prefixPath)\n                        path = path.nodeLink\n                    treeBeta = _Tree()\n                    for k in prefixPaths:\n                        treeBeta.addPrefixPath(k, mapSupportBeta, self._minSup)\n                    if len(treeBeta.root.child) > 0:\n                        treeBeta.createHeaderList(mapSupportBeta, self._minSup)\n                        self._frequentPatternGrowthGenerate(treeBeta, prefix, prefixLength + 1, mapSupportBeta)\n    \n    def startMine(self):\n        \"\"\"\n        main program to start the operation\n\n        \"\"\"\n        self._startTime = _ab._time.time()\n        if self._iFile is None:\n            raise Exception(\"Please enter the file path or file name:\")\n        self._creatingItemSets()\n        self._minSup = self._convert(self._minSup)\n        self._finalPatterns = {}\n        self._frequentOneItem()\n        self._mapSupport = {k: v for k, v in self._mapSupport.items() if v >= self._minSup}\n        _itemSetBuffer = [k for k, v in sorted(self._mapSupport.items(), key=lambda x: x[1], reverse=True)]\n        for i in self._Database:\n            _transaction = []\n            for j in i:\n                if j in _itemSetBuffer:\n                    _transaction.append(j)\n            _transaction.sort(key=lambda val: self._mapSupport[val], reverse=True)\n            self._tree.addTransaction(_transaction)\n        self._tree.createHeaderList(self._mapSupport, self._minSup)\n        if len(self._tree.headerList) > 0:\n            self._itemSetBuffer = []\n            self._frequentPatternGrowthGenerate(self._tree, self._itemSetBuffer, 0, self._mapSupport)\n        print(\"Correlated Frequent patterns were generated successfully using CorrelatedPatternGrowth algorithm\")\n        self._endTime = _ab._time.time()\n        self._memoryUSS = float()\n        self._memoryRSS = float()\n        process = _ab._psutil.Process(_ab._os.getpid())\n        self._memoryUSS = process.memory_full_info().uss\n        self._memoryRSS = process.memory_info().rss\n\n    def getMemoryUSS(self):\n        \"\"\"\n        Total amount of USS memory consumed by the mining process will be retrieved from this function\n\n        :return: returning USS memory consumed by the mining process\n        :rtype: float\n        \"\"\"\n\n        return self._memoryUSS\n\n    def getMemoryRSS(self):\n        \"\"\"\n        Total amount of RSS memory consumed by the mining process will be retrieved from this function\n\n        :return: returning RSS memory consumed by the mining process\n        :rtype: float\n        \"\"\"\n\n        return self._memoryRSS\n\n    def getRuntime(self):\n        \"\"\"\n        Calculating the total amount of runtime taken by the mining process\n\n\n        :return: returning total amount of runtime taken by the mining process\n        :rtype: float\n        \"\"\"\n\n        return self._endTime - self._startTime\n\n    def getPatternsAsDataFrame(self):\n        \"\"\"\n\n        Storing final frequent patterns in a dataframe\n\n        :return: returning frequent patterns in a dataframe\n        :rtype: pd.DataFrame\n        \"\"\"\n\n        dataframe = {}\n        data = []\n        for a, b in self._finalPatterns.items():\n            data.append([a, b])\n            dataframe = _ab._pd.DataFrame(data, columns=['Patterns', 'Support'])\n        return dataframe\n\n    def savePatterns(self, outFile):\n        \"\"\"\n        Complete set of frequent patterns will be loaded in to a output file\n\n        :param outFile: name of the output file\n        :type outFile: file\n        \"\"\"\n        self._oFile = outFile\n        writer = open(self._oFile, 'w+')\n        for x, y in self._finalPatterns.items():\n            pat = \"\"\n            for i in x:\n                pat += str(i) + \" \"\n            patternsAndSupport = pat + \": \" + str(y)\n            writer.write(\"%s \\n\" % patternsAndSupport)\n\n    def getPatterns(self):\n        \"\"\"\n        Function to send the set of frequent patterns after completion of the mining process\n\n        :return: returning frequent patterns\n        :rtype: dict\n        \"\"\"\n        return self._finalPatterns\n\n\nif __name__ == \"__main__\":\n    _ap = str()\n    if len(_ab._sys.argv) == 5 or len(_ab._sys.argv) == 6:\n        if len(_ab._sys.argv) == 6:\n            _ap = CPGrowth(_ab._sys.argv[1], _ab._sys.argv[3], float(_ab._sys.argv[4]), _ab._sys.argv[5])\n        if len(_ab._sys.argv) == 5:\n            _ap = CPGrowth(_ab._sys.argv[1], _ab._sys.argv[3], float(_ab._sys.argv[4]))\n        _ap.startMine()\n        _correlatedPatterns = _ap.getPatterns()\n        print(\"Total number of correlated-Frequent Patterns:\", len(_correlatedPatterns))\n        _ap.savePatterns(_ab._sys.argv[2])\n        _memUSS = _ap.getMemoryUSS()\n        print(\"Total Memory in USS:\", _memUSS)\n        _memRSS = _ap.getMemoryRSS()\n        print(\"Total Memory in RSS\", _memRSS)\n        _run = _ap.getRuntime()\n        print(\"Total ExecutionTime in seconds:\", _run)\n    else:\n        l = [0.0007, 0.0009, 0.001, 0.002, 0.003, 0.01]\n        for i in l:\n            ap = CPGrowth('https://www.u-aizu.ac.jp/~udayrage/datasets/transactionalDatabases/transactional_retail.csv',\n                          i, 0.7)\n            ap.startMine()\n            print(ap._minSup, ap._minAllConf, len(ap._Database))\n            correlatedPatterns = ap.getPatterns()\n            print(\"Total number of correlated-Frequent Patterns:\", len(correlatedPatterns))\n            ap.savePatterns('/Users/Likhitha/Downloads/output')\n            memUSS = ap.getMemoryUSS()\n            print(\"Total Memory in USS:\", memUSS)\n            memRSS = ap.getMemoryRSS()\n            print(\"Total Memory in RSS\", memRSS)\n            run = ap.getRuntime()\n            print(\"Total ExecutionTime in seconds:\", run)\n        print(\"Error! The number of input parameters do not match the total number of parameters provided\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/PAMI/correlatedPattern/basic/CPGrowth.py b/PAMI/correlatedPattern/basic/CPGrowth.py
--- a/PAMI/correlatedPattern/basic/CPGrowth.py	(revision 5bccda2b2f839c8f97fc320ed497577d81af09d1)
+++ b/PAMI/correlatedPattern/basic/CPGrowth.py	(date 1662732541519)
@@ -552,6 +552,7 @@
         self._minSup = self._convert(self._minSup)
         self._finalPatterns = {}
         self._frequentOneItem()
+
         self._mapSupport = {k: v for k, v in self._mapSupport.items() if v >= self._minSup}
         _itemSetBuffer = [k for k, v in sorted(self._mapSupport.items(), key=lambda x: x[1], reverse=True)]
         for i in self._Database:
